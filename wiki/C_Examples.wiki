#Userspace example of interacting with Raspy Juice.

= 1. Introduction *DRAFT DRAFT DRAFT -- DO NOT RELY YET :-(* =

Add your content here.



Raspy Juice (*_Juice_*) is primarily a power supply board for the Raspberry Pi (*_RPi_*) supplying a regulated +5V via the GPIO header, and with added conveniences of a real-time clock (RTC) and an RS232-level console port. However, it also has a Atmel ATmega168A AVR microcontroller (*_MCU_*) attached to the RPi as an I2C slave, and has its GPIO and analog pins exposed out for simple interfacing experiments. See HardwareDescription. The MCU itself is running a firmware service that emulates an I2C register set, which allows a userspace application to control and interact with the interfaces.

This document is to show how to interact with this AVR microcontroller from sel-fwritten userspace programs.

= 2. Pre-requisites =

For a userspace application to communicate with the AVR microcontroller, the are several pre-requites that must be met. 
  *(1) linux kernel must be enabled with the I2c bus and 
  *(2) the Raspy Juice microcontroller must be seen as an I2C slave 
  *(3) communicate with Raspy Juice firmware services with its emulated I2C registers.

=== 2.1 Setting up the I2C linux kernel bus ===
Generally everything written here is for the RPi running the Raspbian/Debian/Wheezy/armhf stock distribution from the Raspberry Pi foundation.
In this distribution, the I2C modules are blacklisted by default in */etc/modprobe.d/raspi-blacklist.conf*. It is OK to leave this file untouched, because modules can be instructed to preload at debian linux boot time by the /etc/modules.conf or */etc/modules* files.

Edit */etc/modules* and add the two lines so that it will at least look like the two i2c lines are there. (you'd have to be root to do this, or sudo) and reboot.
{{{
# /etc/modules: kernel modules to load at boot time.
#
# This file contains the names of kernel modules that should be loaded
# at boot time, one per line. Lines beginning with "#" are ignored.
# Parameters can be specified after the module name.

snd-bcm2835
i2c-dev
i2c-bcm2708
}}}
Then reboot. After which, you should be able to list the i2c busses in the */dev* directory loike below:
{{{
pi@rpdev /etc $ ls -l /dev/*i2c*
crw-rw---T 1 root root 89, 0 Aug  4 04:19 /dev/i2c-0
crw-rw---T 1 root root 89, 1 Aug  4 04:19 /dev/i2c-1
}}}

=== 2.2 Verifying Raspy Juice as an I2C device on the kernel bus ===
For interacting with I2C busses and devices, the proper tools will have to be installed.

{{{
sudo apt-get update
sudo apt-get install i2c-tools
}}}
When the above tools are installed, a group called *_i2c_* is automatically made. When the above listing of /dev is performed again, the I2C busses will be owned by the group.
{{{
pi@rpdev /etc $ ls -l /dev/*i2c*
crw-rw---T 1 root i2c 89, 0 Jan  1  1970 /dev/i2c-0
crw-rw---T 1 root i2c 89, 1 Jan  1  1970 /dev/i2c-1
}}}



Now, non-root users need to be upgraded to interact with I2C busses and devices. 
{{{
sudo usermod -aG i2c yourusername
}}}


Then, verify that Raspy Juice is on the I2C-0 bus.
{{{
pi@rpdev ~ $ ls -l /dev/i2c*
crw-rw---T 1 root i2c 89, 0 Jan  1  1970 /dev/i2c-0
crw-rw---T 1 root i2c 89, 1 Jan  1  1970 /dev/i2c-1

pi@rpdev ~ $ i2cdetect -l
i2c-0	i2c       	bcm2708_i2c.0                   	I2C adapter
i2c-1	i2c       	bcm2708_i2c.1                   	I2C adapter

pi@rpdev ~ $ i2cdetect -y 0
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- 48 -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- UU -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- --                         
pi@rpdev ~ $ 

}}}

= 3. Communicating with Raspy Juice =

Reading / writing to Raspy Juice I2C registers. See I2CemulatedSlaveRegisters. Need i2c-dev and libraries.

{{{
sudo apt-get update
sudo apt-get install libi2c-dev
}}}


=== 3.1 Opening a I2C bus device ===

{{{
#include <linux/i2c-dev.h>
#include <linux/fcntl.h>

    file = open(devname, O_RDWR);
    if (file < 0) {
      /* ERROR HANDLING; you can check errno to see what went wrong */
      printf("open %s: error = %d\n", devname, file);
      exit(1);
    }
    else
      printf("open %s: succeeded.\n", devname);

    if (ioctl(file, I2C_SLAVE, addr) < 0) {
      /* ERROR HANDLING; you can check errno to see what went wrong */
      printf("open i2c slave 0x%02x: error = %s\n", addr, "dunno");
      exit(1);
    }
    else
      printf("open i2c slave 0x%02x: succeeded.\n", addr);
}}}

=== 3.2 Reading and Writing to a Juice I2C register ===
Using the libi2c library call for read byte,
{{{
        rval = i2c_smbus_read_byte_data(file, subreg); 
}}}

Write byte
{{{
        rval = i2c_smbus_write_byte_data(file, subreg, data);
}}}


=== 3.3 Reading the status register ===

=== 3.4 Reading the firmware version ===

=== 3.5 Controlling the servo outputs ===

=== 3.6 Reading the analog-to-digital convertors ===

=== 3.7 RS232 Interface ===

=== 3.8 RS485 Interface ===

=== 3.9 GPIO Interface ===